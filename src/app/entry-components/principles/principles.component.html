<mat-accordion>
  <mat-expansion-panel>
    <mat-expansion-panel-header>
      <mat-panel-title>
        <h2>Immutability</h2>
      </mat-panel-title>
    </mat-expansion-panel-header>

    <mat-card>
      <mat-card-title> How do I leverage Immutability and why should I?
      </mat-card-title>
      <ul>
        <li>
          Achieved by protecting conventional branches like develop, release and master in your source control provider
          (i.e. GitHub or GitLab) which prevents force-pushing.
        </li>
        <li>
          Guarantees that you can never create a problem that you cannot quickly fix.
        </li>
        <li>
          Guarantees that you do not break consumers or contributors of forked and cloned repositories.
        </li>
      </ul>
    </mat-card>

    <mat-card>
      <mat-card-title>Avoid Mutability (the opposite of Immutability)</mat-card-title>
      <ul>
        <li>Defined here as the act of force-pushing to a shared repository or branch therein</li>
        <li>Alters shared history and causes rehashing.</li>
        <li>Produces theoretical (or actual) <a target="_blank" href="https://semver.org"><button
              mat-button>semver</button></a> violatation.</li>
        <li>Potentially breaks integration with every linked repository and consuming developer due to
          propagated need to reconcile histories.</li>
        <li>Potentially deletes code.</li>
        <li>Should only be done in exceptional scenarios where there is a pre-existing problem with a
          repository or branch therein.</li>
        <li>Should only be done after first creating a backup branch (or repo) from which to restore.
        </li>
      </ul>
    </mat-card>

  </mat-expansion-panel>

  <mat-expansion-panel>
    <mat-expansion-panel-header>
      <mat-panel-title>
        <h2>Atomicity</h2>
      </mat-panel-title>
    </mat-expansion-panel-header>

    <mat-card>
      <mat-card-title>
        Atomicity refers essentially to working with only 1 commit
      </mat-card-title>
      <ul>
        <li>
          You only need one commit to integrate your changes with any other change set.
        </li>

        <li>Easier to audit, migrate or revert.</li>

        <li>It is ridiculously easier to integrate your changes when you have a lot of conflicts across a lot of commits
          because you donot have to deal with any additional history reconciliation.</li>


      </ul>
    </mat-card>

    <mat-card>
      <mat-card-title>
        How do I leverage this principle?
      </mat-card-title>
      <ol>
        <li>
          Commit once and amend all changes to that commit (fastest).
        </li>
        <li>
          Squashing (can be accomplished via interactive rebase or reset --soft).
        </li>
      </ol>
    </mat-card>

  </mat-expansion-panel>


  <mat-expansion-panel>
    <mat-expansion-panel-header>
      <mat-panel-title>
        <h2>Polymorphism</h2>
      </mat-panel-title>
    </mat-expansion-panel-header>

    <mat-card>
      <mat-card-title>
        Commands work with any ref or commit hash
      </mat-card-title>
      <ul>
        <li>
          A ref is one of several types of git identifiers that points to the commit hash that git calculated whenever
          the specified revision was committed.
        </li>
        <li>
          Example ref: Tags generated by build servers like v1.1.1.
        </li>
        <li>
          Example ref: Tags created by users like i-love-it-because-it-works.
        </li>
        <li>
          Example ref: Local branch names like develop.
        </li>
        <li>
          Example ref: Remote branches via fully-qualified remote/branch expressions like origin/master.
        </li>
        <li>
          Example ref: Relative expressions the move forward or backward with respect to another ref like HEAD~200.
        </li>
        <li>
          Example of calculating ref by running a command to determine common ancestry:
          <code>git checkout myBranch && git merge-base --independent develop</code>
          <code>abc123 ### example output for above command</code>
        </li>
      </ul>
    </mat-card>

    <mat-card>
      <mat-card-title>
        How do I leverage this principle?
      </mat-card-title>
      <ol>
        <li>
          Notice how git dynamically resolves the refs for you when viewing logs, running commands, or evaulating
          expressions like HEAD~3.
        </li>
        <li>
          Use git commands and branch names (which are floating aliases to the most recent commit on a given branch) to
          dynamically evaulate the commit hash.
        </li>
      </ol>
    </mat-card>

  </mat-expansion-panel>


  <mat-expansion-panel>
    <mat-expansion-panel-header>
      <mat-panel-title>
        <h2>Specificity</h2>
      </mat-panel-title>
    </mat-expansion-panel-header>

    <mat-card>
      <mat-card-title>
        Some git commands take two refs as parameters and default to the current ref (referred to as HEAD) if one parameter is omitted.
      </mat-card-title>
      <ul>
        <li>
          Using the implied ref HEAD is dynamic and convenient but leaves greater opening for mistakes since commands
          are no longer deterministic because they depend on another command to validate or set HEAD to desired
          position.
        </li>
        <li>
          Use another expression, parameter, or command to specify the second, optional ref to eliminate ambiguity
          before, during and after you run your commands.
          <code>git branch myNewBranch ### no idea what we are copying if this command is viewed in isolation</code>
          <code>git branch myNewBranch develop ### specifity eliminates the above-illustrated ambiguity</code>
        </li>
      </ul>
    </mat-card>

  </mat-expansion-panel>

</mat-accordion>